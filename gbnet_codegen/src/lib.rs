// gbnet_codegen/src/main.rs - Advanced code generator with high-quality output

use anyhow::{Result, Context};
use clap::{Parser, ValueEnum};
use std::fs;
use std::path::{Path, PathBuf};
use syn::{parse_file, Item, ItemStruct, ItemEnum, Fields, Type, Attribute, Meta, Lit, Expr};
use quote::ToTokens;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Parser)]
#[command(name = "gbnet_codegen")]
#[command(about = "Generate high-quality C# networking code from Rust definitions")]
struct Cli {
    /// Input Rust file or directory
    input: PathBuf,
    
    /// Output file path
    #[arg(short, long, default_value = "Generated/Packets.cs")]
    output: PathBuf,
    
    /// C# namespace
    #[arg(short, long, default_value = "GamePackets")]
    namespace: String,
    
    /// Generate mode
    #[arg(short, long, value_enum, default_value = "unity")]
    mode: GenerateMode,
    
    /// Watch for changes
    #[arg(short, long)]
    watch: bool,
    
    /// Generate tests
    #[arg(long)]
    tests: bool,
    
    /// Generate benchmarks
    #[arg(long)]
    benchmarks: bool,
}

#[derive(Copy, Clone, PartialEq, Eq, ValueEnum)]
enum GenerateMode {
    Unity,
    Godot,
    Console,
}

#[derive(Debug, Clone)]
struct PacketInfo {
    name: String,
    fields: Vec<FieldInfo>,
    is_enum: bool,
    enum_variants: Vec<EnumVariant>,
    attributes: HashMap<String, String>,
    doc_comment: Option<String>,
}

#[derive(Debug, Clone)]
struct FieldInfo {
    name: String,
    ty: FieldType,
    bits: Option<u32>,
    max_len: Option<usize>,
    doc_comment: Option<String>,
    attributes: HashMap<String, String>,
}

#[derive(Debug, Clone)]
struct EnumVariant {
    name: String,
    fields: Vec<FieldInfo>,
    discriminant: Option<u32>,
}

#[derive(Debug, Clone)]
enum FieldType {
    U8, U16, U32, U64,
    I8, I16, I32, I64,
    F32, F64,
    Bool,
    String,
    Vec(Box<FieldType>),
    Array(Box<FieldType>, usize),
    Option(Box<FieldType>),
    Custom(String),
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    println!("ðŸš€ GBNet Advanced Code Generator");
    println!("  Mode: {:?}", cli.mode);
    println!("  Namespace: {}", cli.namespace);
    
    let packets = parse_packets(&cli.input)?;
    println!("ðŸ“¦ Found {} packet definitions", packets.len());
    
    let code = generate_csharp_advanced(&packets, &cli)?;
    
    // Ensure output directory exists
    if let Some(parent) = cli.output.parent() {
        fs::create_dir_all(parent)?;
    }
    
    fs::write(&cli.output, code)?;
    println!("âœ… Generated {} ({} KB)", cli.output.display(), code.len() / 1024);
    
    if cli.tests {
        let test_code = generate_tests(&packets, &cli)?;
        let test_path = cli.output.with_extension("Tests.cs");
        fs::write(&test_path, test_code)?;
        println!("âœ… Generated tests: {}", test_path.display());
    }
    
    if cli.benchmarks {
        let bench_code = generate_benchmarks(&packets, &cli)?;
        let bench_path = cli.output.with_extension("Benchmarks.cs");
        fs::write(&bench_path, bench_code)?;
        println!("âœ… Generated benchmarks: {}", bench_path.display());
    }
    
    Ok(())
}

fn parse_packets(path: &Path) -> Result<Vec<PacketInfo>> {
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read {}", path.display()))?;
    
    let ast = parse_file(&content)
        .with_context(|| format!("Failed to parse {}", path.display()))?;
    
    let mut packets = Vec::new();
    
    for item in ast.items {
        match item {
            Item::Struct(s) => {
                if has_network_serialize(&s.attrs) {
                    packets.push(parse_struct(&s)?);
                }
            }
            Item::Enum(e) => {
                if has_network_serialize(&e.attrs) {
                    packets.push(parse_enum(&e)?);
                }
            }
            _ => {}
        }
    }
    
    Ok(packets)
}

fn generate_csharp_advanced(packets: &[PacketInfo], cli: &Cli) -> Result<String> {
    let mut code = String::new();
    
    // File header
    code.push_str(&format!(r#"// <auto-generated>
//     This code was generated by gbnet_codegen.
//     
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
{}

namespace {}
{{
"#, 
        match cli.mode {
            GenerateMode::Unity => "using UnityEngine;",
            GenerateMode::Godot => "using Godot;",
            _ => "",
        },
        cli.namespace
    ));
    
    // First, generate the BitBuffer implementation
    code.push_str(&generate_bitbuffer_advanced());
    code.push_str("\n");
    
    // Generate interfaces
    code.push_str(r#"    /// <summary>
    /// Interface for all network packets
    /// </summary>
    public interface INetworkPacket
    {
        void Serialize(BitBuffer buffer);
        int GetSizeInBits();
    }
    
    /// <summary>
    /// Interface for packets with known max size
    /// </summary>
    public interface IFixedSizePacket : INetworkPacket
    {
        int MaxSizeInBits { get; }
    }
"#);
    
    // Generate each packet
    for packet in packets {
        code.push_str(&generate_packet_advanced(packet, cli)?);
        code.push_str("\n");
    }
    
    // Generate helper classes
    code.push_str(&generate_helpers(packets, cli)?);
    
    code.push_str("}\n");
    
    Ok(code)
}

fn generate_packet_advanced(packet: &PacketInfo, cli: &Cli) -> Result<String> {
    let mut code = String::new();
    
    // Documentation
    if let Some(doc) = &packet.doc_comment {
        code.push_str(&format!("    /// <summary>\n    /// {}\n    /// </summary>\n", doc));
    }
    
    // Attributes
    match cli.mode {
        GenerateMode::Unity => code.push_str("    [Serializable]\n"),
        _ => {}
    }
    
    // Class declaration
    let interfaces = if has_fixed_size(packet) {
        ": IFixedSizePacket"
    } else {
        ": INetworkPacket"
    };
    
    code.push_str(&format!("    public sealed class {} {}\n    {{\n", packet.name, interfaces));
    
    // Constants
    if has_fixed_size(packet) {
        let size = calculate_fixed_size(packet);
        code.push_str(&format!("        public const int MAX_SIZE_BITS = {};\n", size));
        code.push_str(&format!("        public const int MAX_SIZE_BYTES = {};\n\n", (size + 7) / 8));
        code.push_str(&format!("        public int MaxSizeInBits => MAX_SIZE_BITS;\n\n"));
    }
    
    // Fields/Properties
    for field in &packet.fields {
        if let Some(doc) = &field.doc_comment {
            code.push_str(&format!("        /// <summary>{}</summary>\n", doc));
        }
        
        let cs_type = field_type_to_csharp_advanced(&field.ty);
        let prop_name = to_pascal_case(&field.name);
        
        // Generate property with validation
        match &field.ty {
            FieldType::String => {
                code.push_str(&format!("        private string _{} = string.Empty;\n", field.name));
                code.push_str(&format!("        public string {} \n        {{\n", prop_name));
                code.push_str(&format!("            get => _{};\n", field.name));
                if let Some(max_len) = field.max_len {
                    code.push_str(&format!("            set => _{} = value?.Length > {} ? value.Substring(0, {}) : (value ?? string.Empty);\n", 
                        field.name, max_len, max_len));
                } else {
                    code.push_str(&format!("            set => _{} = value ?? string.Empty;\n", field.name));
                }
                code.push_str("        }\n\n");
            }
            _ => {
                if let Some(bits) = field.bits {
                    // Add validation for bit-packed fields
                    let max_value = (1u64 << bits) - 1;
                    code.push_str(&format!("        private {} _{};\n", cs_type, field.name));
                    code.push_str(&format!("        public {} {} \n        {{\n", cs_type, prop_name));
                    code.push_str(&format!("            get => _{};\n", field.name));
                    code.push_str(&format!("            set\n            {{\n"));
                    code.push_str(&format!("                if (value > {})\n", max_value));
                    code.push_str(&format!("                    throw new ArgumentOutOfRangeException(nameof(value), $\"Value {{value}} exceeds {} bits (max {})\");\n", bits, max_value));
                    code.push_str(&format!("                _{} = value;\n", field.name));
                    code.push_str("            }\n        }\n\n");
                } else {
                    code.push_str(&format!("        public {} {} {{ get; set; }}\n\n", cs_type, prop_name));
                }
            }
        }
    }
    
    // Constructors
    code.push_str("        public ") ;
    code.push_str(&packet.name);
    code.push_str("() { }\n\n");
    
    // Constructor with all parameters
    if !packet.fields.is_empty() {
        code.push_str(&format!("        public {}(\n", packet.name));
        for (i, field) in packet.fields.iter().enumerate() {
            let cs_type = field_type_to_csharp_advanced(&field.ty);
            let param_name = to_camel_case(&field.name);
            code.push_str(&format!("            {} {}", cs_type, param_name));
            if i < packet.fields.len() - 1 {
                code.push_str(",");
            }
            code.push_str("\n");
        }
        code.push_str("        )\n        {\n");
        for field in &packet.fields {
            let prop_name = to_pascal_case(&field.name);
            let param_name = to_camel_case(&field.name);
            code.push_str(&format!("            {} = {};\n", prop_name, param_name));
        }
        code.push_str("        }\n\n");
    }
    
    // Serialize method
    code.push_str("        public void Serialize(BitBuffer buffer)\n        {\n");
    code.push_str("            if (buffer == null) throw new ArgumentNullException(nameof(buffer));\n\n");
    
    for field in &packet.fields {
        code.push_str(&generate_field_serialize_advanced(field)?);
    }
    
    code.push_str("        }\n\n");
    
    // Deserialize method
    code.push_str(&format!("        public static {} Deserialize(BitBuffer buffer)\n", packet.name));
    code.push_str("        {\n");
    code.push_str("            if (buffer == null) throw new ArgumentNullException(nameof(buffer));\n\n");
    code.push_str(&format!("            var packet = new {}();\n", packet.name));
    
    for field in &packet.fields {
        code.push_str(&generate_field_deserialize_advanced(field)?);
    }
    
    code.push_str("            return packet;\n");
    code.push_str("        }\n\n");
    
    // GetSizeInBits method
    code.push_str("        public int GetSizeInBits()\n        {\n");
    if has_fixed_size(packet) {
        code.push_str("            return MAX_SIZE_BITS;\n");
    } else {
        code.push_str("            int size = 0;\n");
        for field in &packet.fields {
            code.push_str(&generate_size_calculation(field)?);
        }
        code.push_str("            return size;\n");
    }
    code.push_str("        }\n\n");
    
    // ToString override
    code.push_str("        public override string ToString()\n        {\n");
    code.push_str(&format!("            return $\"{}[", packet.name));
    for (i, field in packet.fields.iter().enumerate() {
        let prop_name = to_pascal_case(&field.name);
        code.push_str(&format!("{}={{{}}}", prop_name, prop_name));
        if i < packet.fields.len() - 1 {
            code.push_str(", ");
        }
    }
    code.push_str("]\";\n        }\n\n");
    
    // Equals and GetHashCode
    code.push_str(&generate_equality_members(packet)?);
    
    code.push_str("    }\n");
    
    Ok(code)
}

fn generate_bitbuffer_advanced() -> String {
    r#"    /// <summary>
    /// High-performance bit-level serialization buffer
    /// </summary>
    public sealed class BitBuffer
    {
        private byte[] buffer;
        private int bitPosition;
        private int bitCapacity;
        private readonly bool isReading;
        
        private const int DEFAULT_CAPACITY = 1024;
        private const int GROWTH_FACTOR = 2;
        
        /// <summary>
        /// Gets the current bit position in the buffer
        /// </summary>
        public int BitPosition => bitPosition;
        
        /// <summary>
        /// Gets the current byte position in the buffer
        /// </summary>
        public int BytePosition => (bitPosition + 7) >> 3;
        
        /// <summary>
        /// Gets whether this buffer is in reading mode
        /// </summary>
        public bool IsReading => isReading;
        
        /// <summary>
        /// Creates a new BitBuffer for writing
        /// </summary>
        public BitBuffer(int capacityBytes = DEFAULT_CAPACITY)
        {
            buffer = new byte[capacityBytes];
            bitCapacity = capacityBytes * 8;
            bitPosition = 0;
            isReading = false;
        }
        
        /// <summary>
        /// Creates a new BitBuffer for reading from existing data
        /// </summary>
        public BitBuffer(byte[] data)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            buffer = data;
            bitCapacity = data.Length * 8;
            bitPosition = 0;
            isReading = true;
        }
        
        /// <summary>
        /// Resets the bit position to the beginning
        /// </summary>
        public void Reset()
        {
            bitPosition = 0;
        }
        
        /// <summary>
        /// Gets the buffer contents as a byte array
        /// </summary>
        public byte[] ToArray()
        {
            int byteCount = BytePosition;
            if (byteCount == 0) return Array.Empty<byte>();
            
            var result = new byte[byteCount];
            Array.Copy(buffer, 0, result, 0, byteCount);
            return result;
        }
        
        /// <summary>
        /// Ensures the buffer has enough capacity for the specified number of additional bits
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void EnsureCapacity(int additionalBits)
        {
            if (isReading) return;
            
            int requiredBits = bitPosition + additionalBits;
            if (requiredBits > bitCapacity)
            {
                int requiredBytes = (requiredBits + 7) >> 3;
                int newCapacity = Math.Max(buffer.Length * GROWTH_FACTOR, requiredBytes);
                Array.Resize(ref buffer, newCapacity);
                bitCapacity = newCapacity * 8;
            }
        }
        
        /// <summary>
        /// Writes the specified number of bits from a value
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteBits(ulong value, int bits)
        {
            if (bits < 0 || bits > 64)
                throw new ArgumentOutOfRangeException(nameof(bits), "Bits must be between 0 and 64");
            
            if (bits == 0) return;
            
            EnsureCapacity(bits);
            
            // Mask to ensure we only write the specified bits
            if (bits < 64)
                value &= (1UL << bits) - 1;
            
            // Fast path for aligned bytes
            if ((bitPosition & 7) == 0 && (bits & 7) == 0)
            {
                int bytes = bits >> 3;
                int bytePos = bitPosition >> 3;
                
                for (int i = bytes - 1; i >= 0; i--)
                {
                    buffer[bytePos++] = (byte)(value >> (i * 8));
                }
                
                bitPosition += bits;
                return;
            }
            
            // Bit-by-bit for unaligned
            for (int i = bits - 1; i >= 0; i--)
            {
                int byteIndex = bitPosition >> 3;
                int bitIndex = bitPosition & 7;
                
                if ((value >> i) & 1)
                    buffer[byteIndex] |= (byte)(1 << (7 - bitIndex));
                else
                    buffer[byteIndex] &= (byte)~(1 << (7 - bitIndex));
                
                bitPosition++;
            }
        }
        
        /// <summary>
        /// Reads the specified number of bits into a value
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ulong ReadBits(int bits)
        {
            if (bits < 0 || bits > 64)
                throw new ArgumentOutOfRangeException(nameof(bits), "Bits must be between 0 and 64");
            
            if (bits == 0) return 0;
            
            if (bitPosition + bits > bitCapacity)
                throw new InvalidOperationException("Buffer underflow");
            
            ulong result = 0;
            
            // Fast path for aligned bytes
            if ((bitPosition & 7) == 0 && (bits & 7) == 0)
            {
                int bytes = bits >> 3;
                int bytePos = bitPosition >> 3;
                
                for (int i = 0; i < bytes; i++)
                {
                    result = (result << 8) | buffer[bytePos++];
                }
                
                bitPosition += bits;
                return result;
            }
            
            // Bit-by-bit for unaligned
            for (int i = 0; i < bits; i++)
            {
                int byteIndex = bitPosition >> 3;
                int bitIndex = bitPosition & 7;
                
                if ((buffer[byteIndex] >> (7 - bitIndex)) & 1)
                    result |= 1UL << (bits - 1 - i);
                
                bitPosition++;
            }
            
            return result;
        }
        
        // Type-specific write methods
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteBool(bool value) => WriteBits(value ? 1UL : 0UL, 1);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUInt8(byte value, int bits = 8) => WriteBits(value, bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUInt16(ushort value, int bits = 16) => WriteBits(value, bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUInt32(uint value, int bits = 32) => WriteBits(value, bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUInt64(ulong value, int bits = 64) => WriteBits(value, bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteInt8(sbyte value, int bits = 8) => WriteBits((ulong)value, bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteInt16(short value, int bits = 16) => WriteBits((ulong)value, bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteInt32(int value, int bits = 32) => WriteBits((ulong)value, bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteInt64(long value, int bits = 64) => WriteBits((ulong)value, bits);
        
        public void WriteFloat(float value)
        {
            WriteBits(BitConverter.ToUInt32(BitConverter.GetBytes(value), 0), 32);
        }
        
        public void WriteDouble(double value)
        {
            WriteBits(BitConverter.ToUInt64(BitConverter.GetBytes(value), 0), 64);
        }
        
        public void WriteString(string value, int maxLengthBits = 8)
        {
            if (value == null) value = string.Empty;
            
            byte[] bytes = Encoding.UTF8.GetBytes(value);
            int maxLength = (1 << maxLengthBits) - 1;
            int length = Math.Min(bytes.Length, maxLength);
            
            WriteBits((ulong)length, maxLengthBits);
            
            for (int i = 0; i < length; i++)
            {
                WriteUInt8(bytes[i]);
            }
        }
        
        // Type-specific read methods
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ReadBool() => ReadBits(1) != 0;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte ReadUInt8(int bits = 8) => (byte)ReadBits(bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ushort ReadUInt16(int bits = 16) => (ushort)ReadBits(bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadUInt32(int bits = 32) => (uint)ReadBits(bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ulong ReadUInt64(int bits = 64) => ReadBits(bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public sbyte ReadInt8(int bits = 8) => (sbyte)ReadBits(bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public short ReadInt16(int bits = 16) => (short)ReadBits(bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ReadInt32(int bits = 32) => (int)ReadBits(bits);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public long ReadInt64(int bits = 64) => (long)ReadBits(bits);
        
        public float ReadFloat()
        {
            uint bits = ReadUInt32();
            return BitConverter.ToSingle(BitConverter.GetBytes(bits), 0);
        }
        
        public double ReadDouble()
        {
            ulong bits = ReadUInt64();
            return BitConverter.ToDouble(BitConverter.GetBytes(bits), 0);
        }
        
        public string ReadString(int maxLengthBits = 8)
        {
            int length = (int)ReadBits(maxLengthBits);
            if (length == 0) return string.Empty;
            
            byte[] bytes = new byte[length];
            for (int i = 0; i < length; i++)
            {
                bytes[i] = ReadUInt8();
            }
            
            return Encoding.UTF8.GetString(bytes);
        }
    }
"#.to_string()
}

// Helper functions...
fn has_network_serialize(attrs: &[Attribute]) -> bool {
    attrs.iter().any(|attr| {
        if let Ok(Meta::List(list)) = attr.parse_meta() {
            if list.path.is_ident("derive") {
                return list.nested.iter().any(|n| {
                    if let syn::NestedMeta::Meta(Meta::Path(path)) = n {
                        path.is_ident("NetworkSerialize")
                    } else {
                        false
                    }
                });
            }
        }
        false
    })
}

fn parse_struct(s: &ItemStruct) -> Result<PacketInfo> {
    let mut packet = PacketInfo {
        name: s.ident.to_string(),
        fields: Vec::new(),
        is_enum: false,
        enum_variants: Vec::new(),
        attributes: HashMap::new(),
        doc_comment: extract_doc_comment(&s.attrs),
    };
    
    if let Fields::Named(fields) = &s.fields {
        for field in &fields.named {
            if let Some(name) = &field.ident {
                packet.fields.push(FieldInfo {
                    name: name.to_string(),
                    ty: parse_type(&field.ty),
                    bits: get_bits_attr(&field.attrs),
                    max_len: get_max_len_attr(&field.attrs),
                    doc_comment: extract_doc_comment(&field.attrs),
                    attributes: HashMap::new(),
                });
            }
        }
    }
    
    Ok(packet)
}

fn parse_enum(e: &ItemEnum) -> Result<PacketInfo> {
    // TODO: Implement enum parsing
    Ok(PacketInfo {
        name: e.ident.to_string(),
        fields: Vec::new(),
        is_enum: true,
        enum_variants: Vec::new(),
        attributes: HashMap::new(),
        doc_comment: extract_doc_comment(&e.attrs),
    })
}

fn parse_type(ty: &Type) -> FieldType {
    let type_str = ty.to_token_stream().to_string();
    match type_str.as_str() {
        "u8" => FieldType::U8,
        "u16" => FieldType::U16,
        "u32" => FieldType::U32,
        "u64" => FieldType::U64,
        "i8" => FieldType::I8,
        "i16" => FieldType::I16,
        "i32" => FieldType::I32,
        "i64" => FieldType::I64,
        "f32" => FieldType::F32,
        "f64" => FieldType::F64,
        "bool" => FieldType::Bool,
        "String" => FieldType::String,
        s if s.starts_with("Vec <") => {
            // Parse Vec<T>
            FieldType::Vec(Box::new(FieldType::Custom("T".to_string())))
        }
        s if s.starts_with("Option <") => {
            // Parse Option<T>
            FieldType::Option(Box::new(FieldType::Custom("T".to_string())))
        }
        _ => FieldType::Custom(type_str),
    }
}

fn get_bits_attr(attrs: &[Attribute]) -> Option<u32> {
    attrs.iter().find_map(|attr| {
        if attr.path.is_ident("bits") {
            if let Ok(Meta::NameValue(nv)) = attr.parse_meta() {
                if let Lit::Int(lit) = nv.lit {
                    return lit.base10_parse().ok();
                }
            }
        }
        None
    })
}

fn get_max_len_attr(attrs: &[Attribute]) -> Option<usize> {
    attrs.iter().find_map(|attr| {
        if attr.path.is_ident("max_len") {
            if let Ok(Meta::NameValue(nv)) = attr.parse_meta() {
                if let Lit::Int(lit) = nv.lit {
                    return lit.base10_parse().ok();
                }
            }
        }
        None
    })
}

fn extract_doc_comment(attrs: &[Attribute]) -> Option<String> {
    let docs: Vec<String> = attrs.iter()
        .filter_map(|attr| {
            if attr.path.is_ident("doc") {
                if let Ok(Meta::NameValue(nv)) = attr.parse_meta() {
                    if let Lit::Str(s) = nv.lit {
                        return Some(s.value().trim().to_string());
                    }
                }
            }
            None
        })
        .collect();
    
    if docs.is_empty() {
        None
    } else {
        Some(docs.join(" "))
    }
}

fn field_type_to_csharp_advanced(ty: &FieldType) -> String {
    match ty {
        FieldType::U8 => "byte",
        FieldType::U16 => "ushort",
        FieldType::U32 => "uint",
        FieldType::U64 => "ulong",
        FieldType::I8 => "sbyte",
        FieldType::I16 => "short",
        FieldType::I32 => "int",
        FieldType::I64 => "long",
        FieldType::F32 => "float",
        FieldType::F64 => "double",
        FieldType::Bool => "bool",
        FieldType::String => "string",
        FieldType::Vec(inner) => format!("List<{}>", field_type_to_csharp_advanced(inner)),
        FieldType::Array(inner, _) => format!("{}[]", field_type_to_csharp_advanced(inner)),
        FieldType::Option(inner) => format!("{}?", field_type_to_csharp_advanced(inner)),
        FieldType::Custom(name) => name,
    }.to_string()
}

fn generate_field_serialize_advanced(field: &FieldInfo) -> Result<String> {
    let prop_name = to_pascal_case(&field.name);
    let mut code = String::new();
    
    match &field.ty {
        FieldType::Bool => {
            code.push_str(&format!("            buffer.WriteBool({});\n", prop_name));
        }
        FieldType::String => {
            let bits = field.max_len.map(|m| ((m + 1) as f64).log2().ceil() as u8).unwrap_or(8);
            code.push_str(&format!("            buffer.WriteString({}, {});\n", prop_name, bits));
        }
        FieldType::Vec(inner) => {
            let len_bits = field.max_len.map(|m| ((m + 1) as f64).log2().ceil() as u8).unwrap_or(16);
            code.push_str(&format!("            // Vector with {}-bit length\n", len_bits));
            code.push_str(&format!("            buffer.WriteBits((ulong){}.Count, {});\n", prop_name, len_bits));
            code.push_str(&format!("            foreach (var item in {})\n", prop_name));
            code.push_str("            {\n");
            match inner.as_ref() {
                FieldType::Custom(type_name) => {
                    code.push_str("                item.Serialize(buffer);\n");
                }
                _ => {
                    code.push_str(&format!("                buffer.Write{}(item);\n", 
                        type_suffix(&field.ty)));
                }
            }
            code.push_str("            }\n");
        }
        _ => {
            if let Some(bits) = field.bits {
                code.push_str(&format!("            buffer.WriteBits((ulong){}, {});\n", prop_name, bits));
            } else {
                match &field.ty {
                    FieldType::F32 => code.push_str(&format!("            buffer.WriteFloat({});\n", prop_name)),
                    FieldType::F64 => code.push_str(&format!("            buffer.WriteDouble({});\n", prop_name)),
                    _ => {
                        let method = match &field.ty {
                            FieldType::U8 => "WriteUInt8",
                            FieldType::U16 => "WriteUInt16",
                            FieldType::U32 => "WriteUInt32",
                            FieldType::U64 => "WriteUInt64",
                            FieldType::I8 => "WriteInt8",
                            FieldType::I16 => "WriteInt16",
                            FieldType::I32 => "WriteInt32",
                            FieldType::I64 => "WriteInt64",
                            _ => "WriteBits",
                        };
                        code.push_str(&format!("            buffer.{}({});\n", method, prop_name));
                    }
                }
            }
        }
    }
    
    Ok(code)
}

fn generate_field_deserialize_advanced(field: &FieldInfo) -> Result<String> {
    let prop_name = to_pascal_case(&field.name);
    let mut code = String::new();
    
    match &field.ty {
        FieldType::Bool => {
            code.push_str(&format!("            packet.{} = buffer.ReadBool();\n", prop_name));
        }
        FieldType::String => {
            let bits = field.max_len.map(|m| ((m + 1) as f64).log2().ceil() as u8).unwrap_or(8);
            code.push_str(&format!("            packet.{} = buffer.ReadString({});\n", prop_name, bits));
        }
        FieldType::Vec(inner) => {
            let len_bits = field.max_len.map(|m| ((m + 1) as f64).log2().ceil() as u8).unwrap_or(16);
            let inner_type = field_type_to_csharp_advanced(inner);
            code.push_str(&format!("            int {}Count = (int)buffer.ReadBits({});\n", field.name, len_bits));
            code.push_str(&format!("            packet.{} = new List<{}>({}Count);\n", prop_name, inner_type, field.name));
            code.push_str(&format!("            for (int i = 0; i < {}Count; i++)\n", field.name));
            code.push_str("            {\n");
            match inner.as_ref() {
                FieldType::Custom(type_name) => {
                    code.push_str(&format!("                packet.{}.Add({}.Deserialize(buffer));\n", prop_name, type_name));
                }
                _ => {
                    code.push_str(&format!("                packet.{}.Add(buffer.Read{}());\n", 
                        prop_name, type_suffix(&field.ty)));
                }
            }
            code.push_str("            }\n");
        }
        _ => {
            if let Some(bits) = field.bits {
                let cs_type = field_type_to_csharp_advanced(&field.ty);
                code.push_str(&format!("            packet.{} = ({})buffer.ReadBits({});\n", 
                    prop_name, cs_type, bits));
            } else {
                match &field.ty {
                    FieldType::F32 => code.push_str(&format!("            packet.{} = buffer.ReadFloat();\n", prop_name)),
                    FieldType::F64 => code.push_str(&format!("            packet.{} = buffer.ReadDouble();\n", prop_name)),
                    _ => {
                        let method = match &field.ty {
                            FieldType::U8 => "ReadUInt8",
                            FieldType::U16 => "ReadUInt16",
                            FieldType::U32 => "ReadUInt32",
                            FieldType::U64 => "ReadUInt64",
                            FieldType::I8 => "ReadInt8",
                            FieldType::I16 => "ReadInt16",
                            FieldType::I32 => "ReadInt32",
                            FieldType::I64 => "ReadInt64",
                            _ => "ReadBits",
                        };
                        code.push_str(&format!("            packet.{} = buffer.{}();\n", prop_name, method));
                    }
                }
            }
        }
    }
    
    Ok(code)
}

fn has_fixed_size(packet: &PacketInfo) -> bool {
    packet.fields.iter().all(|f| {
        match &f.ty {
            FieldType::String => false,
            FieldType::Vec(_) => false,
            _ => true,
        }
    })
}

fn calculate_fixed_size(packet: &PacketInfo) -> u32 {
    packet.fields.iter().map(|f| {
        if let Some(bits) = f.bits {
            bits
        } else {
            match &f.ty {
                FieldType::Bool => 1,
                FieldType::U8 | FieldType::I8 => 8,
                FieldType::U16 | FieldType::I16 => 16,
                FieldType::U32 | FieldType::I32 | FieldType::F32 => 32,
                FieldType::U64 | FieldType::I64 | FieldType::F64 => 64,
                _ => 0,
            }
        }
    }).sum()
}

fn generate_size_calculation(field: &FieldInfo) -> Result<String> {
    let prop_name = to_pascal_case(&field.name);
    
    match &field.ty {
        FieldType::String => {
            let len_bits = field.max_len.map(|m| ((m + 1) as f64).log2().ceil() as u8).unwrap_or(8);
            Ok(format!("            size += {} + (Encoding.UTF8.GetByteCount({} ?? string.Empty) * 8);\n", 
                len_bits, prop_name))
        }
        FieldType::Vec(_) => {
            let len_bits = field.max_len.map(|m| ((m + 1) as f64).log2().ceil() as u8).unwrap_or(16);
            Ok(format!("            size += {}; // length prefix\n            foreach (var item in {}) size += item.GetSizeInBits();\n", 
                len_bits, prop_name))
        }
        _ => {
            if let Some(bits) = field.bits {
                Ok(format!("            size += {};\n", bits))
            } else {
                let bits = match &field.ty {
                    FieldType::Bool => 1,
                    FieldType::U8 | FieldType::I8 => 8,
                    FieldType::U16 | FieldType::I16 => 16,
                    FieldType::U32 | FieldType::I32 | FieldType::F32 => 32,
                    FieldType::U64 | FieldType::I64 | FieldType::F64 => 64,
                    _ => 0,
                };
                Ok(format!("            size += {};\n", bits))
            }
        }
    }
}

fn generate_equality_members(packet: &PacketInfo) -> Result<String> {
    let mut code = String::new();
    
    // Equals
    code.push_str(&format!("        public override bool Equals(object? obj)\n"));
    code.push_str("        {\n");
    code.push_str(&format!("            return obj is {} other && Equals(other);\n", packet.name));
    code.push_str("        }\n\n");
    
    code.push_str(&format!("        public bool Equals({} other)\n", packet.name));
    code.push_str("        {\n");
    code.push_str("            if (other == null) return false;\n");
    code.push_str("            return ");
    
    for (i, field) in packet.fields.iter().enumerate() {
        let prop_name = to_pascal_case(&field.name);
        if i > 0 {
            code.push_str("\n                && ");
        }
        
        match &field.ty {
            FieldType::String => {
                code.push_str(&format!("string.Equals({}, other.{})", prop_name, prop_name));
            }
            FieldType::Vec(_) => {
                code.push_str(&format!("{}.SequenceEqual(other.{})", prop_name, prop_name));
            }
            _ => {
                code.push_str(&format!("{} == other.{}", prop_name, prop_name));
            }
        }
    }
    
    code.push_str(";\n        }\n\n");
    
    // GetHashCode
    code.push_str("        public override int GetHashCode()\n");
    code.push_str("        {\n");
    code.push_str("            unchecked\n            {\n");
    code.push_str("                int hash = 17;\n");
    
    for field in &packet.fields {
        let prop_name = to_pascal_case(&field.name);
        match &field.ty {
            FieldType::String => {
                code.push_str(&format!("                hash = hash * 31 + ({} ?? string.Empty).GetHashCode();\n", prop_name));
            }
            FieldType::Vec(_) => {
                code.push_str(&format!("                hash = hash * 31 + {}.Count;\n", prop_name));
            }
            _ => {
                code.push_str(&format!("                hash = hash * 31 + {}.GetHashCode();\n", prop_name));
            }
        }
    }
    
    code.push_str("                return hash;\n");
    code.push_str("            }\n        }\n");
    
    Ok(code)
}

fn generate_helpers(packets: &[PacketInfo], cli: &Cli) -> Result<String> {
    let mut code = String::new();
    
    // Packet factory
    code.push_str(r#"    /// <summary>
    /// Factory for creating packet instances by type
    /// </summary>
    public static class PacketFactory
    {
        private static readonly Dictionary<Type, Func<BitBuffer, INetworkPacket>> Deserializers = new()
        {
"#);
    
    for packet in packets {
        code.push_str(&format!("            {{ typeof({}), buffer => {}.Deserialize(buffer) }},\n", 
            packet.name, packet.name));
    }
    
    code.push_str(r#"        };
        
        public static INetworkPacket? Deserialize(Type packetType, BitBuffer buffer)
        {
            if (Deserializers.TryGetValue(packetType, out var deserializer))
            {
                return deserializer(buffer);
            }
            return null;
        }
        
        public static T? Deserialize<T>(BitBuffer buffer) where T : INetworkPacket
        {
            return (T?)Deserialize(typeof(T), buffer);
        }
    }
"#);
    
    Ok(code)
}

fn generate_tests(packets: &[PacketInfo], cli: &Cli) -> Result<String> {
    // Generate unit tests for each packet
    Ok("// Unit tests TODO".to_string())
}

fn generate_benchmarks(packets: &[PacketInfo], cli: &Cli) -> Result<String> {
    // Generate benchmarks for serialization performance
    Ok("// Benchmarks TODO".to_string())
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn to_camel_case(s: &str) -> String {
    let pascal = to_pascal_case(s);
    let mut chars = pascal.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_lowercase().chain(chars).collect(),
    }
}

fn type_suffix(ty: &FieldType) -> &'static str {
    match ty {
        FieldType::U8 => "UInt8",
        FieldType::U16 => "UInt16",
        FieldType::U32 => "UInt32",
        FieldType::U64 => "UInt64",
        FieldType::I8 => "Int8",
        FieldType::I16 => "Int16",
        FieldType::I32 => "Int32",
        FieldType::I64 => "Int64",
        FieldType::F32 => "Float",
        FieldType::F64 => "Double",
        FieldType::Bool => "Bool",
        FieldType::String => "String",
        _ => "Unknown",
    }
}